<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cryptocurrency Volatility Index (CVI)</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <link rel="icon" href="data:,">

  <style>
    :root { --fg:#111; --muted:#666; --pill:#eef3ff; --pill-active:#d8e4ff; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: var(--fg); }
    h1 { margin: 0 0 8px 0; }
    .muted { color: var(--muted); font-size: 12px; margin: 6px 0 14px; }
    .tabs { display:flex; gap:8px; overflow-x:auto; padding:6px 0 10px; }
    .tab { white-space:nowrap; padding:6px 12px; border-radius:999px; background:var(--pill); cursor:pointer; font-weight:600; border:0; }
    .tab.active { background:var(--pill-active); }
    .layout { max-width: 1200px; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 2fr 1fr; gap:16px; align-items:start; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px; background:#fff; }
    .signal-title { font-weight:700; }
    .signal-meta { font-size:12px; color:#555; margin-top:4px; }
    canvas { background:#fff; border-radius:8px; }
    hr { border:0; border-top:1px solid #eee; margin:10px 0; }
  </style>
</head>
<body>
  <h1>Cryptocurrency Volatility Index (CVI)</h1>
  <div class="muted" id="runInfo">Loading…</div>

  <div class="tabs" id="assetTabs"></div>

  <div class="layout">
    <div class="row">
      <div class="card">
        <canvas id="cviSeries" height="260"></canvas>
      </div>
      <div class="card" id="signalCard">
        <div class="signal-title">Signal</div>
        <div id="signalBody" class="signal-meta">Waiting…</div>
        <hr/>
        <div class="signal-title" style="margin-top:8px;">Recent signals</div>
        <div id="signalTable" class="signal-meta"></div>
      </div>
    </div>

    <h3 style="margin-top:4px">Volatility smile — ~30-day expiry</h3>
    <div class="card">
      <canvas id="cviSmile" height="260"></canvas>
    </div>
  </div>

  <script>
    let seriesChart = null, smileChart = null;
    let loadSeq = 0;
    let manifestBySymbol = {};

    async function json(url){
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return await r.json();
    }

    function setActiveTab(sym){
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.sym === sym));
    }

    function ctxFor(id){
      const el = document.getElementById(id);
      const existing = Chart.getChart(el);
      if (existing) existing.destroy();
      return el.getContext('2d');
    }

    const nonNull = v => v!=null && isFinite(v);
    const countNonNull = arr => arr.filter(nonNull).length;

    function nonNullMax(arr){
      const nn = arr.filter(nonNull);
      if (!nn.length) return 0.05;
      const m = Math.max(...nn);
      return Math.max(0.05, m);
    }

    // Use both series + smile to pick a sensible per-asset Y max
    function computeUnifiedYMax(series, smile){
      const a = (series||[]).map(p => [p.atm_iv, p.vega_weighted_iv]).flat();
      const b = (smile||[]).map(p => p.iv);
      const m = Math.max(nonNullMax(a), nonNullMax(b));
      return Math.min(Math.max(m * 1.2, 0.05), 3);
    }

    function drawEmpty(ctx){
      return new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: { maintainAspectRatio: false, plugins: { legend: { display:false } } }
      });
    }

    // Build a one-dot synthetic reading from the smile when the time-series is all-null
    function synthFromSmile(smile, spot, ts){
      if (!Array.isArray(smile) || !smile.length) return null;
      const byDist = [...smile].sort((a,b)=>Math.abs(a.strike-spot)-Math.abs(b.strike-spot));
      const atm = byDist[0]?.iv ?? null;
      const near = smile.filter(p => Math.abs(p.strike/spot - 1) <= 0.10);
      const vegaW = (near.length
        ? (near.reduce((s,p)=>s + p.iv/(Math.abs(p.strike-spot)+1e-6),0) /
           near.reduce((s,p)=>s + 1/(Math.abs(p.strike-spot)+1e-6),0))
        : (smile.reduce((s,p)=>s + p.iv,0)/smile.length)
      );
      return [{
        t: ts || new Date().toISOString(),
        spot: spot ?? null,
        days_to_expiry: 30.0,
        atm_iv: atm,
        vega_weighted_iv: vegaW
      }];
    }

    function drawSeries(series, yMax){
      const ctx = ctxFor('cviSeries');
      if (!series || !series.length){ seriesChart = drawEmpty(ctx); return; }

      const labels = series.map(p => new Date(p.t));
      const atm  = series.map(p => (nonNull(p.atm_iv) ? +p.atm_iv : null));
      const vega = series.map(p => (nonNull(p.vega_weighted_iv) ? +p.vega_weighted_iv : null));

      const n = countNonNull(atm) + countNonNull(vega);
      if (n === 0){ seriesChart = drawEmpty(ctx); return; }

      // Show dots when data is sparse; draw a line only when we have ≥2 real points
      const showLine = n >= 2;

      seriesChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label:'CVI (ATM 30-day IV)',
              data: atm,
              borderWidth:2, tension:0.2, spanGaps:true, showLine,
              // draw a visible dot only where the value is non-null
              pointRadius: (ctx) => Number.isFinite(ctx.parsed?.y) ? 3 : 0
            },
            {
              label:'CVI (Vega-weighted IV)',
              data: vega,
              borderWidth:2, tension:0.2, spanGaps:true, showLine,
              pointRadius: (ctx) => nonNull(ctx.raw) ? 3 : 0
            }
          ]
        },
        options: {
          maintainAspectRatio: false,
          normalized: true,
          parsing: false,
          animation: false,
          scales: {
            x: { type: 'time', time: { unit: 'minute' }, ticks: { maxTicksLimit: 8 } },
            y: { min: 0, suggestedMax: yMax, title: { display:true, text:'IV' } }
          },
          plugins: {
            legend: { position: 'top' },
            tooltip: {
              mode: 'index', intersect: false,
              // Safe title: don't rely on parsed.x when nulls exist
              callbacks: { title: (items) => (items && items[0]) ? String(items[0].label) : '' }
            }
          }
        }
      });
    }

    function drawSmile(smile, yMax){
      const ctx = ctxFor('cviSmile');
      if (!Array.isArray(smile) || !smile.length){ smileChart = drawEmpty(ctx); return; }

      smileChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: smile.map(p=>p.strike),
          datasets: [{
            label: 'Implied Volatility',
            data: smile.map(p=>p.iv),
            borderWidth: 2, tension: 0.2, pointRadius: 0
          }]
        },
        options: {
          maintainAspectRatio: false,
          normalized: true,
          animation: false,
          scales: {
            x: { title: { display: true, text: 'Strike' } },
            y: { min: 0, suggestedMax: yMax, title: { display: true, text: 'IV' } }
          },
          plugins: { legend: { position: 'top' } }
        }
      });
    }

    function renderSignals(sigs){
      const body = document.getElementById('signalBody');
      const tbl  = document.getElementById('signalTable');
      if (!sigs || !sigs.length){
        body.textContent = 'No signals yet (need more history).';
        tbl.textContent = '';
        return;
      }
      const last = sigs[sigs.length - 1];
      body.innerHTML = `
        <div><b>${last.recommendation}</b> — strength ${Math.round(last.strength*100)}% (size hint ${last.size_hint}x)</div>
        <div>${last.reason}</div>
        <div>IV: ${last.last_iv?.toFixed?.(4) ?? 'n/a'} | EMA20: ${last.ema20?.toFixed?.(4) ?? 'n/a'} | EMA100: ${last.ema100?.toFixed?.(4) ?? 'n/a'}</div>
        <div>${new Date(last.ts).toLocaleString()}</div>
      `;
      const recent = sigs.slice(-10).reverse().map(s =>
        `<div>• ${new Date(s.ts).toLocaleString()}: <b>${s.recommendation}</b> (${Math.round(s.strength*100)}%)</div>`
      ).join('');
      tbl.innerHTML = recent;
    }

    function buildSyntheticSeriesFromManifest(symbol){
      const snap = manifestBySymbol[symbol]?.latest;
      if (!snap) return [];
      return [{
        t: snap.t || new Date().toISOString(),
        spot: snap.spot ?? null,
        days_to_expiry: snap.days_to_expiry ?? null,
        atm_iv: snap.atm_iv ?? null,
        vega_weighted_iv: snap.vega_weighted_iv ?? null
      }];
    }

    async function loadAsset(sym){
      const mySeq = ++loadSeq;
      setActiveTab(sym);

      try {
        let series = [], smile = [], sigs = [];
        try { series = await json(`${sym}/cvi_timeseries.json`); } catch {}
        try { smile  = await json(`${sym}/cvi.json`); } catch {}
        try { sigs   = await json(`${sym}/signals.json`); } catch {}

        if (mySeq !== loadSeq) return;

        // If the series is missing/empty or effectively all-null, try to synthesize from smile or manifest
        const nonNullCount = (arr) => arr.reduce((n,p)=>n + (nonNull(p.atm_iv)||nonNull(p.vega_weighted_iv) ? 1 : 0), 0);
        if (!Array.isArray(series) || !series.length || nonNullCount(series) === 0) {
          const spot = manifestBySymbol[sym]?.latest?.spot ?? null;
          const ts   = manifestBySymbol[sym]?.latest?.t ?? null;
          const synth = synthFromSmile(Array.isArray(smile)?smile:[], spot, ts) || buildSyntheticSeriesFromManifest(sym);
          series = synth;
          if (!series || !series.length) {
            document.getElementById('runInfo').textContent = `Asset: ${sym} — failed to load data.`;
            drawSeries([], 1); drawSmile([], 1); renderSignals([]);
            return;
          } else {
            document.getElementById('runInfo').textContent = `Asset: ${sym} — showing latest snapshot (synthetic).`;
          }
        } else {
          const last = series[series.length - 1];
          document.getElementById('runInfo').textContent =
            `Asset: ${sym} — Last: ${new Date(last.t).toLocaleString()} — Spot: $${(last.spot||0).toLocaleString()} — DTE: ${last.days_to_expiry ?? 'n/a'}d`;
        }

        const yMax = computeUnifiedYMax(series, Array.isArray(smile) ? smile : []);
        drawSeries(series, yMax);
        drawSmile(Array.isArray(smile) ? smile : [], yMax);
        renderSignals(Array.isArray(sigs) ? sigs : []);
      } catch {
        document.getElementById('runInfo').textContent = `Asset: ${sym} — failed to load data.`;
        ctxFor('cviSeries'); ctxFor('cviSmile');
        document.getElementById('signalBody').textContent = 'No data.';
        document.getElementById('signalTable').textContent = '';
      }
    }

    (async function init(){
      try{
        const manifest = await json('cvi_manifest.json');
        const tabs = document.getElementById('assetTabs');
        tabs.innerHTML = '';
        if (!manifest?.assets?.length){
          document.getElementById('runInfo').textContent = 'No assets available yet.';
          return;
        }
        manifestBySymbol = {};
        manifest.assets.forEach(a => {
          manifestBySymbol[a.symbol] = a;
          const el = document.createElement('button');
          el.className = 'tab';
          el.dataset.sym = a.symbol;
          el.textContent = a.symbol;
          el.onclick = () => loadAsset(a.symbol);
          tabs.appendChild(el);
        });
        loadAsset(manifest.assets[0].symbol);
      }catch{
        document.getElementById('runInfo').textContent = 'Failed to load manifest.';
      }
    })();
  </script>
</body>
</html>
