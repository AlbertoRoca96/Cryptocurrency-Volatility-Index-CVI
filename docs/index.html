<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Cryptocurrency Volatility Index (CVI)</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
  <link rel="icon" href="data:,">

  <style>
    :root { --fg:#111; --muted:#666; --pill:#eef3ff; --pill-active:#d8e4ff; --ok:#0a0; --warn:#d97706; --bad:#b91c1c; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 24px; color: var(--fg); }
    h1 { margin: 0 0 8px 0; }
    .muted { color: var(--muted); font-size: 12px; margin: 6px 0 14px; }
    .tabs { display:flex; gap:8px; overflow-x:auto; padding:6px 0 10px; }
    .tab { white-space:nowrap; padding:6px 12px; border-radius:999px; background:var(--pill); cursor:pointer; font-weight:600; border:0; }
    .tab.active { background:var(--pill-active); }
    .layout { max-width: 1200px; display: grid; gap: 18px; }
    .row { display:grid; grid-template-columns: 2fr 1fr; gap:16px; align-items:start; }
    .card { border:1px solid #eee; border-radius:12px; padding:12px; background:#fff; }
    .signal-title { font-weight:700; }
    .signal-meta { font-size:12px; color:#555; margin-top:4px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; background:#f5f5f5; border:1px solid #eee; margin-left:8px;}
    .badge.warn { background:#fff7ed; border-color:#fde68a; color:#92400e; }
    canvas { background:#fff; border-radius:8px; }
    hr { border:0; border-top:1px solid #eee; margin:10px 0; }
    .orders { font-size:12px; line-height:1.4; }
    .orders b { font-weight:700; }
  </style>
</head>
<body>
  <h1>Cryptocurrency Volatility Index (CVI)</h1>
  <div class="muted" id="runInfo">Loading…</div>

  <div class="tabs" id="assetTabs"></div>

  <div class="layout">
    <div class="row">
      <div class="card">
        <canvas id="cviSeries" height="260"></canvas>
      </div>

      <div class="card" id="rightCard">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div class="signal-title">Signal</div>
          <div id="smileBadge" class="badge" title="Real quotes vs synthetic fill"></div>
        </div>
        <div id="signalBody" class="signal-meta">Waiting…</div>
        <hr/>
        <div class="signal-title" style="margin-top:8px;">Risk & Trade</div>
        <div id="riskBody" class="signal-meta">Calculating…</div>

        <!-- NEW: Model Forecast block -->
        <hr/>
        <div class="signal-title" style="margin-top:8px;">Model Forecast (1d)</div>
        <div id="modelBox" class="signal-meta">Loading…</div>

        <hr/>
        <div class="signal-title" style="margin-top:8px;">Recent signals</div>
        <div id="signalTable" class="signal-meta"></div>
        <hr/>
        <div class="signal-title" style="margin-top:8px;">Orders (paper)</div>
        <div id="ordersBox" class="orders"></div>
      </div>
    </div>

    <h3 style="margin-top:4px">Volatility smile — ~30-day expiry</h3>
    <div class="card">
      <canvas id="cviSmile" height="260"></canvas>
    </div>
  </div>

  <script>
    let seriesChart = null, smileChart = null;
    let loadSeq = 0;
    let manifestBySymbol = {};

    async function json(url){
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return await r.json();
    }

    function setActiveTab(sym){
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.sym === sym));
    }

    function ctxFor(id){
      const el = document.getElementById(id);
      const existing = Chart.getChart(el);
      if (existing) existing.destroy();
      return el.getContext('2d');
    }

    const nonNull = v => v!=null && isFinite(v);

    function nonNullMax(arr){
      const nn = arr.filter(nonNull);
      if (!nn.length) return 0.05;
      const m = Math.max(...nn);
      return Math.max(0.05, m);
    }

    // Use both series + smile to pick a sensible per-asset Y max
    function computeUnifiedYMax(series, smile){
      const a = (series||[]).map(p => [p.atm_iv, p.vega_weighted_iv]).flat();
      const b = (smile||[]).map(p => p.iv);
      const m = Math.max(nonNullMax(a), nonNullMax(b));
      return Math.min(Math.max(m * 1.2, 0.05), 3);
    }

    function drawEmpty(ctx){
      return new Chart(ctx, {
        type: 'line',
        data: { labels: [], datasets: [] },
        options: { maintainAspectRatio: false, plugins: { legend: { display:false } } }
      });
    }

    // Build a one-dot synthetic reading from the smile when the time-series is all-null
    function synthFromSmile(smile, spot, ts){
      if (!Array.isArray(smile) || !smile.length) return null;
      const byDist = [...smile].sort((a,b)=>Math.abs(a.strike-spot)-Math.abs(b.strike-spot));
      const atm = byDist[0]?.iv ?? null;
      const near = smile.filter(p => Math.abs(p.strike/spot - 1) <= 0.10);
      const vegaW = (near.length
        ? (near.reduce((s,p)=>s + p.iv/(Math.abs(p.strike-spot)+1e-6),0) /
           near.reduce((s,p)=>s + 1/(Math.abs(p.strike-spot)+1e-6),0))
        : (smile.reduce((s,p)=>s + p.iv,0)/smile.length)
      );
      return [{
        t: ts || new Date().toISOString(),
        spot: spot ?? null,
        days_to_expiry: 30.0,
        atm_iv: atm,
        vega_weighted_iv: vegaW
      }];
    }

    // Robust single-point rendering with highlight dots
    function drawSeries(series, yMax){
      const ctx = ctxFor('cviSeries');

      const ptsAtm = (series || [])
        .filter(p => p && p.t && nonNull(p.atm_iv))
        .map(p => ({ x: new Date(p.t), y: +p.atm_iv }));

      const ptsVega = (series || [])
        .filter(p => p && p.t && nonNull(p.vega_weighted_iv))
        .map(p => ({ x: new Date(p.t), y: +p.vega_weighted_iv }));

      if ((ptsAtm.length + ptsVega.length) === 0){
        seriesChart = drawEmpty(ctx);
        return;
      }

      const lastAtm  = ptsAtm.length  ? [ptsAtm[ptsAtm.length-1]]   : [];
      const lastVega = ptsVega.length ? [ptsVega[ptsVega.length-1]] : [];

      seriesChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [
            {
              label:'CVI (ATM 30-day IV)',
              data: ptsAtm,
              borderWidth:2, tension:0.2,
              spanGaps:true, showLine: ptsAtm.length >= 2,
              pointRadius: 3
            },
            {
              label:'CVI (Vega-weighted IV)',
              data: ptsVega,
              borderWidth:2, tension:0.2,
              spanGaps:true, showLine: ptsVega.length >= 2,
              pointRadius: 3
            },
            ...(lastAtm.length ? [{
              label:'ATM point',
              type:'scatter',
              data:lastAtm,
              pointRadius:5,
              showLine:false
            }] : []),
            ...(lastVega.length ? [{
              label:'Vega point',
              type:'scatter',
              data:lastVega,
              pointRadius:5,
              showLine:false
            }] : [])
          ]
        },
        options: {
          maintainAspectRatio: false,
          normalized: true,
          parsing: true,
          animation: false,
          scales: {
            x: { type: 'time', time: { unit: 'minute' }, ticks: { maxTicksLimit: 8 } },
            y: { min: 0, suggestedMax: yMax, title: { display:true, text:'IV' } }
          },
          plugins: {
            legend: { position: 'top' },
            tooltip: {
              mode: 'index', intersect: false,
              callbacks: { title: (items) => (items && items[0]) ? String(items[0].label) : '' }
            }
          }
        }
      });
    }

    function drawSmile(smile, yMax){
      const ctx = ctxFor('cviSmile');
      if (!Array.isArray(smile) || !smile.length){ smileChart = drawEmpty(ctx); return; }

      smileChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: smile.map(p=>p.strike),
          datasets: [{
            label: 'Implied Volatility',
            data: smile.map(p=>p.iv),
            borderWidth: 2, tension: 0.2, pointRadius: 0
          }]
        },
        options: {
          maintainAspectRatio: false,
          normalized: true,
          animation: false,
          scales: {
            x: { title: { display: true, text: 'Strike' } },
            y: { min: 0, suggestedMax: yMax, title: { display: true, text: 'IV' } }
          },
          plugins: { legend: { position: 'top' } }
        }
      });
    }

    function renderSignals(sigs){
      const body = document.getElementById('signalBody');
      const tbl  = document.getElementById('signalTable');
      if (!sigs || !sigs.length){
        body.textContent = 'No signals yet (need more history).';
        tbl.textContent = '';
        return;
      }
      const last = sigs[sigs.length - 1];
      body.innerHTML = `
        <div><b>${last.recommendation}</b> — strength ${Math.round(last.strength*100)}% (size hint ${last.size_hint}x)</div>
        <div>${last.reason}</div>
        <div>IV: ${last.last_iv?.toFixed?.(4) ?? 'n/a'} | EMA20: ${last.ema20?.toFixed?.(4) ?? 'n/a'} | EMA100: ${last.ema100?.toFixed?.(4) ?? 'n/a'}</div>
        <div>${new Date(last.ts).toLocaleString()}</div>
      `;
      const recent = sigs.slice(-10).reverse().map(s =>
        `<div>• ${new Date(s.ts).toLocaleString()}: <b>${s.recommendation}</b> (${Math.round(s.strength*100)}%)</div>`
      ).join('');
      tbl.innerHTML = recent;
    }

    function renderRisk(risk){
      const el = document.getElementById('riskBody');
      if (!risk || risk.ERI==null){
        el.textContent = 'n/a';
        return;
      }
      const eri = Number(risk.ERI);
      const sigma_d = Number(risk.sigma_d);
      const move = risk.etv?.expected_move_usd ?? null;
      const qty  = risk.etv?.qty ?? null;
      const notl = risk.etv?.notional_usd ?? null;
      const hue = eri < 2 ? 'var(--ok)' : (eri < 4 ? 'var(--warn)' : 'var(--bad)');
      el.innerHTML = `
        <div>ERI: <b style="color:${hue}">${eri.toFixed(2)}</b> &nbsp; (σ<sub>d</sub>: ${(sigma_d||0).toFixed(4)})</div>
        <div>Expected move (1d): <b>$${(move||0).toFixed(2)}</b></div>
        <div>Size hint: <b>${qty?.toFixed?.(6) ?? '0'}</b> (~$${(notl||0).toFixed(2)})</div>
        <div>Budget: $${risk.etv?.risk_budget_usd ?? 0} — Horizon: ${risk.etv?.horizon_days ?? 1}d — Lev: ${risk.etv?.leverage ?? 1}x</div>
      `;
    }

    function renderOrders(orders){
      const box = document.getElementById('ordersBox');
      if (!orders || !orders.length){ box.textContent = 'No orders.'; return; }
      const rows = orders.slice(-8).reverse().map(o =>
        `<div>• ${new Date(o.t).toLocaleString()} — <b>${o.side.toUpperCase()}</b> ${o.qty.toFixed(6)} ${o.symbol} @ ${o.price} (${o.reason})</div>`
      ).join('');
      box.innerHTML = rows;
    }

    function setSmileBadge(meta){
      const el = document.getElementById('smileBadge');
      if (!meta) { el.textContent = ''; return; }
      if (meta.synthetic) {
        el.classList.add('warn');
        el.textContent = 'Synthetic smile';
      } else {
        el.classList.remove('warn');
        el.textContent = 'Real quotes';
      }
    }

    // NEW: model forecast renderer
    function renderModel(pred){
      const box = document.getElementById('modelBox');
      if (!pred || !pred.prediction){
        box.textContent = 'n/a';
        return;
      }
      const p = pred.prediction || {};
      const pct = (p.next_day_return*100);
      const up  = p.prob_up;
      const hue = up >= 0.55 ? 'var(--ok)' : (up <= 0.45 ? 'var(--bad)' : 'var(--warn)');
      box.innerHTML = `
        <div>Next-day return: <b>${pct.toFixed(2)}%</b></div>
        <div>Prob(up): <b style="color:${hue}">${(up*100).toFixed(1)}%</b></div>
        <div class="muted">CV (RMSE): ${pred.cv?.rmse_mean?.toFixed?.(4) ?? '—'}
        ${pred.cv?.auc_mean ? ` | AUC: ${pred.cv.auc_mean.toFixed(3)}` : ''}</div>
        <div class="muted">${new Date(pred.t).toLocaleString()}</div>
      `;
    }

    function buildSyntheticSeriesFromManifest(symbol){
      const snap = manifestBySymbol[symbol]?.latest;
      if (!snap) return [];
      return [{
        t: snap.t || new Date().toISOString(),
        spot: snap.spot ?? null,
        days_to_expiry: snap.days_to_expiry ?? null,
        atm_iv: snap.atm_iv ?? null,
        vega_weighted_iv: snap.vega_weighted_iv ?? null
      }];
    }

    async function loadAsset(sym){
      const mySeq = ++loadSeq;
      setActiveTab(sym);

      try {
        let series = [], smile = [], sigs = [], risk = null, orders = [], smileMeta=null, pred=null;
        try { series = await json(`${sym}/cvi_timeseries.json`); } catch {}
        try { smile  = await json(`${sym}/cvi.json`); } catch {}
        try { sigs   = await json(`${sym}/signals.json`); } catch {}
        try { risk   = await json(`${sym}/risk.json`); } catch {}
        try { orders = await json(`${sym}/orders.json`); } catch {}
        try { smileMeta = await json(`${sym}/smile_meta.json`); } catch {}
        try { pred = await json(`${sym}/predictions.json`); } catch {}

        if (mySeq !== loadSeq) return;

        const nonNullCount = (arr) => arr.reduce((n,p)=>n + ((p && (nonNull(p.atm_iv)||nonNull(p.vega_weighted_iv))) ? 1 : 0), 0);
        if (!Array.isArray(series) || !series.length || nonNullCount(series) === 0) {
          const spot = manifestBySymbol[sym]?.latest?.spot ?? null;
          const ts   = manifestBySymbol[sym]?.latest?.t ?? null;
          const synth = synthFromSmile(Array.isArray(smile)?smile:[], spot, ts) || buildSyntheticSeriesFromManifest(sym);
          series = synth;
          if (!series || !series.length) {
            document.getElementById('runInfo').textContent = `Asset: ${sym} — failed to load data.`;
            drawSeries([], 1); drawSmile([], 1); renderSignals([]); renderRisk(null); renderOrders(null); setSmileBadge(null); renderModel(null);
            return;
          } else {
            document.getElementById('runInfo').textContent = `Asset: ${sym} — showing latest snapshot (synthetic).`;
          }
        } else {
          const last = series[series.length - 1];
          document.getElementById('runInfo').textContent =
            `Asset: ${sym} — Last: ${new Date(last.t).toLocaleString()} — Spot: $${(last.spot||0).toLocaleString()} — DTE: ${last.days_to_expiry ?? 'n/a'}d`;
        }

        const yMax = computeUnifiedYMax(series, Array.isArray(smile) ? smile : []);
        drawSeries(series, yMax);
        drawSmile(Array.isArray(smile) ? smile : [], yMax);
        renderSignals(Array.isArray(sigs) ? sigs : []);
        renderRisk(risk);
        renderOrders(orders);
        setSmileBadge(smileMeta);
        renderModel(pred);
      } catch {
        document.getElementById('runInfo').textContent = `Asset: ${sym} — failed to load data.`;
        ctxFor('cviSeries'); ctxFor('cviSmile');
        document.getElementById('signalBody').textContent = 'No data.';
        document.getElementById('signalTable').textContent = '';
        document.getElementById('riskBody').textContent = 'n/a';
        document.getElementById('ordersBox').textContent = 'No orders.';
        document.getElementById('smileBadge').textContent = '';
        document.getElementById('modelBox').textContent = 'n/a';
      }
    }

    (async function init(){
      try{
        const manifest = await json('cvi_manifest.json');
        const tabs = document.getElementById('assetTabs');
        tabs.innerHTML = '';
        if (!manifest?.assets?.length){
          document.getElementById('runInfo').textContent = 'No assets available yet.';
          return;
        }
        manifestBySymbol = {};
        manifest.assets.forEach(a => {
          manifestBySymbol[a.symbol] = a;
          const el = document.createElement('button');
          el.className = 'tab';
          el.dataset.sym = a.symbol;
          el.textContent = a.symbol;
          el.onclick = () => loadAsset(a.symbol);
          tabs.appendChild(el);
        });
        loadAsset(manifest.assets[0].symbol);
      }catch{
        document.getElementById('runInfo').textContent = 'Failed to load manifest.';
      }
    })();
  </script>
</body>
</html>
